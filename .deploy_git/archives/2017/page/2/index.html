<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="baidu-site-verification" content="nWXA5pz9OB&quot;"><meta name="google-site-verification" content="GV1JH1LWgxtYEzh1ZspR37dC-o6YZWuEfgCQLPnAAMM"><link rel="icon" href="/favicon.png"><link rel="alternate" type="application/rss+xml" title="Agreek的博客" href="https://978420544.github.io/atom.xml"><link rel="stylesheet" href="/styles.css"><link rel="stylesheet" href="/my.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><title>Agreek的博客</title></head><body><div class="container"><div class="columns page-header"><h1>Agreek的博客</h1></div><div class="columns"><div class="navigation"><nav class="menus-main"><a href="/" class="favicon"><img alt="Agreek的博客" src="/favicon.png"></a><a href="/">首页</a><a href="/archives">归档</a><a href="/resume">简历</a><a href="/about">关于</a></nav><nav class="right menus-right"><a href="/atom.xml">RSS</a><a target="_blank" href="https://github.com/978420544">fork on Github</a></nav></div></div><div class="columns"><div class="block-body column three-fourths"><div class="article-widget"><a href="https://github.com/978420544"></a></div><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-4：数据库的锁机制/">转【数据库事务与锁】浅谈@4：数据库的锁机制</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>数据库的读现象浅析中介绍过，在并发访问情况下，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。</p>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><pre><code>在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency control）是确保及时纠正由并发操作导致的错误的一种机制。
</code></pre><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。下面举例说明并发操作带来的数据不一致性问题：</p>
<p>现有两处火车票售票点，同时读取某一趟列车车票数据库中车票余额为 X。两处售票点同时卖出一张车票，同时修改余额为 X -1写回数据库，这样就造成了实际卖出两张火车票而数据库中的记录却只少了一张。 产生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。</p>
<p>封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。</p>
<p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。</p>
<h4 id="锁的分类-oracle"><a href="#锁的分类-oracle" class="headerlink" title="锁的分类(oracle)"></a>锁的分类(oracle)</h4><pre><code>一 按操作划分，可分为DML锁、DDL锁
二 按锁的粒度划分，可分为表级锁, 页级锁, 行级锁（mysql）
三 按锁级别划分，可分为共享锁、排它锁
四 按加锁方式划分，可分为自动锁、显示锁
五 按使用方式划分，可分为乐观锁, 悲观锁
</code></pre><p>DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))。 DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）</p>
<p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506823.html" target="_blank" rel="noopener">《[数据库事务与锁]详解四: 数据库的锁机制》</a></p>
</div></article><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-3：深入分析事务的隔离级别/">转【数据库事物与锁】浅谈@3：深入分析事务的隔离级别</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>在DBMS中，事务保证了一个操作序列可以全部都执行或者全部都不执行（原子性），从一个状态转变到另外一个状态（一致性）。由于事务满足久性。所以一旦事务被提交之后，数据就能够被持久化下来，又因为事务是满足隔离性的，所以，当多个事务同时处理同一个数据的时候，多个事务直接是互不影响的，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生脏读、不可重复读或者幻读等读现象。</p>
<p>在数据库事务的ACID四个属性中，隔离性是一个最常放松的一个。可以在数据操作过程中利用数据库的锁机制或者多版本并发控制机制获取更高的隔离等级。但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。</p>
<p>在软件开发中，几乎每类这样的问题都会有多种最佳实践来供我们参考，很多DBMS定义了多个不同的“事务隔离等级”来控制锁的程度和并发能力。</p>
<p>ANSI/ISO SQL定义的标准隔离级别有四种，从高到底依次为：可序列化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。</p>
<pre><code>本文详细介绍四种事务隔离级别，并通过举例的方式说明不同的级别能解决什么样的读现象。
并且介绍了在关系型数据库中不同的隔离级别的实现原理。

下面将依次介绍这四种事务隔离级别的概念、用法以及解决了哪些问题（读现象）
</code></pre><h3 id="未提交读-Read-uncommitted"><a href="#未提交读-Read-uncommitted" class="headerlink" title="未提交读(Read uncommitted)"></a>未提交读(Read uncommitted)</h3><p>未提交读(READ UNCOMMITTED)是最低的隔离级别。通过名字我们就可以知道，在这种事务隔离级别下，一个事务可以读到另外一个事务未提交的数据。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>事务在读数据的时候并未对数据加锁。
事务在修改数据的时候只对数据增加行级共享锁。
</code></pre><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><pre><code>事务1读取某行记录时，事务2也能对这行记录进行读取、更新（因为事务一并未对数据增加任何锁）

当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本（因为事务二只增加了共享读锁，事务一可以再增加共享读锁读取数据），即使该修改尚未被提交。

事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（因为事务一对数据增加了共享读锁，事务二不能增加排他写锁进行数据的修改）
</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>事务一共查询了两次，在两次查询的过程中，事务二对数据进行了修改，并未提交（commit）。
但是事务一的第二次查询查到了事务二的修改结果。在数据库的读现象浅析中我们介绍过，这种现象我们称之为脏读。

所以，未提交读会导致脏读
</code></pre><h3 id="提交读-Read-committed"><a href="#提交读-Read-committed" class="headerlink" title="提交读(Read committed)"></a>提交读(Read committed)</h3><p>提交读(READ COMMITTED)也可以翻译成读已提交，通过名字也可以分析出，在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。</p>
<h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><pre><code>事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
</code></pre><h4 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h4><pre><code>事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据。）。

事务1读取某行的一瞬间，事务2不能修改该行数据，但是，只要事务1读取完改行数据，事务2就可以对该行数据进行修改。（事务一在读取的一瞬间会对数据增加共享锁，任何其他事务都不能对该行数据增加排他锁。但是事务一只要读完该行数据，就会释放行级共享锁，一旦锁释放，事务二就可以对数据增加排他锁并修改数据）

事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（事务一在更新数据的时候，会对该行数据增加排他锁，知道事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）
</code></pre><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>提交读这种隔离级别保证了读到的任何数据都是提交的数据，避免了脏读(dirty reads)。但是不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据。</p>
<h3 id="可重复读-Repeatable-reads"><a href="#可重复读-Repeatable-reads" class="headerlink" title="可重复读(Repeatable reads)"></a>可重复读(Repeatable reads)</h3><p>可重复读(REPEATABLE READS),由于提交读隔离级别会产生不可重复读的读现象。所以，比提交读更高一个级别的隔离级别就可以解决不可重复读的问题。这种隔离级别就叫可重复读（这名字起的是不是很任性！！）</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><pre><code>事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
</code></pre><h4 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h4><pre><code>事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据。）。

事务1在读取某行记录的整个过程中，事务2都不能修改该行数据（事务一在读取的整个过程会对数据增加共享锁，直到事务提交才会释放锁，所以整个过程中，任何其他事务都不能对该行数据增加排他锁。所以，可重复读能够解决不可重复读的读现象）

事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（事务一在更新数据的时候，会对该行数据增加排他锁，知道事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）
</code></pre><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>1.事务一的第一次查询条件是age BETWEEN 10 AND 30;如果这是有十条记录符合条件。这时，他会给符合条件的这十条记录增加行级共享锁。任何其他事务无法更改这十条记录。</p>
<p>2.事务二执行一条sql语句，语句的内容是向表中插入一条数据。因为此时没有任何事务对表增加表级锁，所以，该操作可以顺利执行。</p>
<p>3.事务一再次执行SELECT * FROM users WHERE age BETWEEN 10 AND 30;时，结果返回的记录变成了十一条，比刚刚增加了一条，增加的这条正是事务二刚刚插入的那条。</p>
<p>所以，事务一的两次范围查询结果并不相同。这也就是幻读。</p>
<h3 id="可序列化-Serializable"><a href="#可序列化-Serializable" class="headerlink" title="可序列化(Serializable)"></a>可序列化(Serializable)</h3><p>可序列化(Serializable)是最高的隔离级别，前面提到的所有的隔离级别都无法解决的幻读，在可序列化的隔离级别中可以解决。</p>
<p>我们说过，产生幻读的原因是事务一在进行范围查询的时候没有增加范围锁(range-locks：给SELECT 的查询中使用一个“WHERE”子句描述范围加锁），所以导致幻读。</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><pre><code>事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；

事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。
</code></pre><h4 id="现象-4"><a href="#现象-4" class="headerlink" title="现象"></a>现象</h4><pre><code>事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。(因为事务一对表增加了表级共享锁，其他事务只能增加共享锁读取数据，不能进行其他任何操作）

事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。（事务一对表增加了表级排他锁，其他事务不能对表增加共享锁或排他锁，也就无法进行任何操作）
</code></pre><p>虽然可序列化解决了脏读、不可重复读、幻读等读现象。但是序列化事务会产生以下效果：</p>
<p>1.无法读取其它事务已修改但未提交的记录。</p>
<p>2.在当前事务完成之前，其它事务不能修改目前事务已读取的记录。</p>
<p>3.在当前事务完成之前，其它事务所插入的新记录，其索引键值不能在当前事务的任何语句所读取的索引键范围中。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>四种事务隔离级别从隔离程度上越来越高，但同时在并发性上也就越来越低。之所以有这么几种隔离级别，就是为了方便开发人员在开发过程中根据业务需要选择最合适的隔离级别。</p>
<p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506755.html" target="_blank" rel="noopener">《[数据库事务与锁]详解三: 深入分析事务的隔离级别》</a></p>
</div></article><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-2：数据库的读现象/">转【数据库事务与锁】浅谈@2：数据库的读现象</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。其中包括脏读、不可重复读和幻读。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</p>
<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</p>
<p>一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><pre><code>幻读(phantom read)”是不可重复读(Non-repeatable reads)的一种特殊场景：当事务没有获取范围锁的情况下执行SELECT … WHERE操作可能会发生“幻影读(phantom read)”。
</code></pre><p>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检锁范围为只读，这样就避免了幻读。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>要想解决脏读、不可重复读、幻读等读现象，那么就需要提高事务的隔离级别。但与此同时，事务的隔离级别越高，并发能力也就越低。所以，还需要读者根据业务需要进行权衡。</p>
<p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506755.html" target="_blank" rel="noopener">《[数据库事务与锁]详解二: 数据库的读现象浅析》</a></p>
</div></article><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-1：彻底理解数据库事务/">转【数据库事务与锁】浅谈@1：彻底理解数据库事务</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p>
<pre><code>1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。
</code></pre><p>当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</p>
<p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>
<pre><code>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。
</code></pre><h4 id="原子性与隔离行"><a href="#原子性与隔离行" class="headerlink" title="原子性与隔离行"></a>原子性与隔离行</h4><p>一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关。<br>比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。</p>
<p>因此，事务的原子性与一致性缺一不可。</p>
<p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506745.html" target="_blank" rel="noopener">《[数据库事务与锁]详解一: 彻底理解数据库事务》</a></p>
<h3 id="特性浅析"><a href="#特性浅析" class="headerlink" title="特性浅析"></a>特性浅析</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><pre><code>无论一个事务里有多少执行步骤，这所有的步骤合起来是一个最小的执行单元，要么不做，要么全做，不存在只做到一半情况。比如银行转账，转出跟转入这两个包含在一个事务里的动作就是原子的。要么不转出也不转入，转出了就要转入。
</code></pre><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><pre><code>事务执行前与执行后数据内在的逻辑始终是成立的。比如转账前与转账后两人存款的总和始终不变。
</code></pre><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><pre><code>虽说事务是原子的，要么不做，要么全做，不存在做一半的情况。但是从代码实现上来说，事务里的步骤还是一步一步执行的，还是存在事务做到一半的情况。比如转账，代码怎么写？就两行代码，是先转出扣钱，再转入加钱。两行代码中间，也就是转出之后，转入之前，此时数据是不一致的。那怎样始终保证数据一致？那就用一个类似自欺欺人的办法，让转账这个事务在完成之前对别人都不可见，事务完成之前别人看到的都是转账前的状态，看不到转账步骤中间不一致的状态，所谓”隔离”。
</code></pre><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><pre><code>事务做完了就是做完了，就生效了。就像钱转给别人后当前这比转账交易就结束了，不可能再倒回来。
</code></pre></div></article><article><header><h2><a href="/2017/10/09/Java定时任务集群部署方式浅谈/">Java定时任务集群部署方式浅谈</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-09</time><ul class="tags left"><li><a href="/categories/quartz/">QUARTZ</a></li></ul><ul class="tags right"><li><a href="/tags/java/">Java</a></li><li><a href="/tags/spring/">Spring</a></li><li><a href="/tags/quartz/">QUARTZ</a></li></ul></div><div class="markdown-body"><p>本篇基于QUARTZ的定时任务，主要介绍一下定时任务的集群部署方式，方法一：QUARTZ支持的集群部署；方法二：通过HTTP调用的集群部署。</p>
<h3 id="任务调度-Job"><a href="#任务调度-Job" class="headerlink" title="任务调度 Job"></a>任务调度 Job</h3><p>任务调度 Job 如同数据库作业或 Windows计划任务，是分布式系统中异步和批处理的关键。我们的 Job分为 WinJob 和 HttpJob：WinJob是操作系统级别的定时任务，使用开源的框架Quartz 实现；而 HttpJob 则是采用 URL方式可定时调用微服务。HttpJob 借助集群巧妙地解决了 WinJob的单点和发布问题，并集中管理所有的调度规则，调度规则有简单规则和 Cron 表达式。HttpJob 它简单易用，但间隔时间不能低于 1分钟，毕竟通过 URL 方式来调度并不高效。</p>
<p>–转自 <a href="http://mp.weixin.qq.com/s/AbUGOWN27FEUPWgDQkF_Dw" target="_blank" rel="noopener">《可参考的才是有价值的：中小型研发团队架构落地实践18篇，含案例、代码》</a></p>
<h3 id="QUARTZ模式"><a href="#QUARTZ模式" class="headerlink" title="QUARTZ模式"></a>QUARTZ模式</h3><p>一个Quartz集群中的每个节点是一个独立的Quartz应用，它又管理着其他的节点。这就意味着你必须对每个节点分别启动或停止。Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的。</p>
<p>　<br>Quartz Scheduler自身是察觉不到被集群的，只有配置给Scheduler的JDBC JobStore才知道。当QuartzScheduler启动时，它调用JobStore的schedulerStarted()方法，它告诉JobStoreScheduler已经启动了。schedulerStarted() 方法是在JobStoreSupport类中实现的。JobStoreSupport类会根据quartz.properties文件中的设置来确定Scheduler实例是否参与到集群中。假如配置了集群，一个新的ClusterManager类的实例就被创建、初始化并启动。ClusterManager是在JobStoreSupport类中的一个内嵌类，继承了java.lang.Thread，它会定期运行，并对Scheduler实例执行检入的功能。Scheduler也要查看是否有任何一个别的集群节点失败了。检入操作执行周期在quartz.properties中配置。</p>
<p>–转自 <a href="http://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html" target="_blank" rel="noopener">《Quartz集群原理及配置应用》</a></p>
<h3 id="HTTP模式"><a href="#HTTP模式" class="headerlink" title="HTTP模式"></a>HTTP模式</h3><p>HTTP模式，简而言之就是URL调用模式，通过发布的微服务调用来完成对应的任务，相应的定时可采用对应合适的调度工具，定时触发这些URL的调用。</p>
</div></article><article><header><h2><a href="/2017/07/28/JAVA中文编码和中文字符长度问题和解决方案/">JAVA中文编码和中文字符长度问题和解决方案</a></h2></header><div class="article-meta clearfix"><time class="left">2017-07-28</time><ul class="tags left"><li><a href="/categories/java/">Java</a></li></ul><ul class="tags right"><li><a href="/tags/java/">Java</a></li></ul></div><div class="markdown-body"><p><a href="http://blog.csdn.net/u012506661/article/details/52752541" target="_blank" rel="noopener">【转】JAVA中文编码和中文字符长度问题和解决方案</a></p>
<p>本文说明了Java对中文问题产生的原因，并给出了对中文问题的解决方案。同时引发出了对中英文混和的字符串的长度问题，并且给出解决方案的实现。</p>
<h3 id="1-Java中文问题的产生"><a href="#1-Java中文问题的产生" class="headerlink" title="1.Java中文问题的产生"></a>1.Java中文问题的产生</h3><p>Java为了对全球的常用文字编码系统进行处理，采用了Unicode字符编码集。Unicode字符编码集是一种重要的交互和显示的通用字符编码标准，常见的有UTF-8、UTF-16、UCS-2、UCS-4等。国际标准组织为中文、日文和韩文字符（即CJK大字符集）对应的数据区间主要是4E00-9FFF，每一个字符对应惟一的一个编码。例如，“中文”这两个字对应的Unicode码分别是：0x4E2D、0x6587。下面这段代码System.out.println((char)0x4E2D + “” + (char)0x6587 ) ;就可以打印出“中文”来。我们通常使用的字符编码是一种双字节字符集（DBCS）。它与Unicode的编码机制有很大差别。Java语言的中文处理问题一般就是，如何将DBCS编码的字节串相互转换为正确的Unicode编码的字符串。所有中文问题的出现都是因为字节串没有被正确转换所至。中文问题的出现一般都是在几种不同语言的操作系统中交互信息的时候出现的。</p>
<h3 id="2-Java中文问题解决方案"><a href="#2-Java中文问题解决方案" class="headerlink" title="2.Java中文问题解决方案"></a>2.Java中文问题解决方案</h3><p>首先，请确保你的JDK的版本是稳定的新版本，这是正确处理Java中文问题的前提条件。</p>
<h4 id="2-1其他内码和Unicode码之间的转换"><a href="#2-1其他内码和Unicode码之间的转换" class="headerlink" title="2.1其他内码和Unicode码之间的转换"></a>2.1其他内码和Unicode码之间的转换</h4><p>解决问题的根源在于正确的处理各种内码和Unicode码进行相互转换。Java的String类提供了转换方法，具体用法是new String( byte[] , encoding ) ，即为用指定的字符编码方式转换指定的字节数组生成一个新的String。<br>比如：String abc = new String ( “hi…中文”.getBytes( “GB2312” ) , “GB2312” ) ;<br>其中，”hi…中文”.getBytes( “GB2312” )是按照GB2312的字符编码方式把该 String 转换成字节数组。然后再按照GB2312的方式生成一个abc的String对象。</p>
<h4 id="2-2让JDK用你指定的编码方式编译程序"><a href="#2-2让JDK用你指定的编码方式编译程序" class="headerlink" title="2.2让JDK用你指定的编码方式编译程序"></a>2.2让JDK用你指定的编码方式编译程序</h4><p>在用javac编译程序时，编译器会用系统的默认编码来编译Java程序。用如下命令编译javac -encoding GB2312 Xxx.java，则是指定用GB2312的编码来进行编译。</p>
<h4 id="2-3JDBC中的中文问题"><a href="#2-3JDBC中的中文问题" class="headerlink" title="2.3JDBC中的中文问题"></a>2.3JDBC中的中文问题</h4><p>JDBC（Java DataBase Connectivity）是Java程序访问数据库的一个统一的接口。JDBC在网络传输过程中，大多数会采用本地编码格式来传输中文字符，例如中文字符“0x4175”会被转成“0x41”和“0x75”进行传输。因此需要对 JDBC返回的字符以及要发给JDBC的字符进行转换。当用JDBC向数据库中插入数据和查询数据时，则需要作编码转换。所以当应用程序访问数据时，在入口和出口处都要作编码转换。对于中文数据，数据库字符编码的设置应当保证数据的完整性，比如GB2312、GBK、UTF-8 等都是可选的数据库编码。<br>比如：转换成UTF-8进行传输<br>sqlstr1 = new String(sqlstr1.getBytes(“GB2312”),” “UTF-8”);<br>转换成GB2312码进行显示<br>sqlstr2 = new String(sqlstr2.getBytes(“UTF-8”),”GB2312”);</p>
<h3 id="3-Java中文编码失败情况说明"><a href="#3-Java中文编码失败情况说明" class="headerlink" title="3.Java中文编码失败情况说明"></a>3.Java中文编码失败情况说明</h3><p>如果出现编码失败，在显示时会出现两种结果：“?”或者“□”。“?”表示转码错误；“□”表示转码失败。如果出现“?”，只有追本溯源查找问题所在才能解决问题；如果出现“□”，则表示可以在此基础上进一步进行转码操作直到成功。</p>
<h3 id="4-Java中文编码带来的字符串长度问题"><a href="#4-Java中文编码带来的字符串长度问题" class="headerlink" title="4.Java中文编码带来的字符串长度问题"></a>4.Java中文编码带来的字符串长度问题</h3><p>Java的中文问题处理系统除了在显示方面会出现问题外，还会对包含中文字符的字符串的长度的判断带来一定的问题。在C语言中，一个中文字符是2个字节，而在Java程序中，中文字符的长度是根据编码不同而不同的。下面的程序就可以看出问题所在。<br>测试程序如下，测试字符串为“中文abc”，测试平台为中文Win XP sp2。<br>public class ChineseCharacterTest<br>{<br>    public static void main( String [] args ) throws Exception<br>    {<br>        //按iso8859-1编码<br>        String iso = new String( “中文abc”.getBytes( “GB2312” ) , “ISO8859-1” );<br>        //按GB2312编码<br>        String gb = new String( iso.getBytes( “ISO8859-1” ) , “gb2312” ) ;<br>        //按utf-8编码<br>        String utf_8 = new String( iso.getBytes( “ISO8859-1” ) , “UTF-8” ) ;<br>//下面分别打印出编码后的字符串和长度<br>        System.out.println( “iso is :” + iso + “, the length is:” + iso.length() ) ;<br>        System.out.println( “gb is :” + gb + “, the length is :” + gb.length() ) ;<br>        System.out.println( “utf-8 is:” + utf_8 + “, the length is :” + utf_8.length() ) ;<br>    }<br>}<br>用GB2312编码进行编译程序，其运行结果是：<br>iso is :????????abc, the length is:7<br>gb is :中文abc, the length is :5<br>utf-8 is:????????abc, the length is :7<br>可以看出，在ISO8859-1和UTF-8中一个中文字符按照2个长度单位处理，在GB编码中一个中文字符按照1个长度单位处理。这样在进行字符截取时就要相当注意这个问题。如果在ISO8859-1或UTF-8中一不小心将中文截去半个，将会出现致命的错误。</p>
<h3 id="5-中文字符长度问题的解决方案"><a href="#5-中文字符长度问题的解决方案" class="headerlink" title="5.中文字符长度问题的解决方案"></a>5.中文字符长度问题的解决方案</h3><h4 id="5-1为了更好的解决中文字符的长度，我们设计并实现了下面的方法。基本思想是根据中文编码的编码区间，判断字符是否为中文字符，然后再作进一步的处理。"><a href="#5-1为了更好的解决中文字符的长度，我们设计并实现了下面的方法。基本思想是根据中文编码的编码区间，判断字符是否为中文字符，然后再作进一步的处理。" class="headerlink" title="5.1为了更好的解决中文字符的长度，我们设计并实现了下面的方法。基本思想是根据中文编码的编码区间，判断字符是否为中文字符，然后再作进一步的处理。"></a>5.1为了更好的解决中文字符的长度，我们设计并实现了下面的方法。基本思想是根据中文编码的编码区间，判断字符是否为中文字符，然后再作进一步的处理。</h4><p>程序如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">static</span> <span class="string">int</span> <span class="string">getChineseLength(</span> <span class="string">String</span> <span class="string">name</span> <span class="string">,</span> <span class="string">String</span> <span class="string">endcoding</span> <span class="string">)</span></span><br><span class="line">        <span class="string">throws</span> <span class="string">Exception&#123;</span></span><br><span class="line">    <span class="string">int</span> <span class="string">len</span> <span class="string">=</span> <span class="number">0</span> <span class="string">;</span> <span class="string">//定义返回的字符串长度</span></span><br><span class="line">    <span class="string">int</span> <span class="string">j</span> <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span><br><span class="line">    <span class="string">//按照指定编码得到byte[]</span></span><br><span class="line">    <span class="string">byte</span> <span class="string">[]</span> <span class="string">b_name</span> <span class="string">=</span> <span class="string">name.getBytes(</span> <span class="string">endcoding</span> <span class="string">)</span> <span class="string">;</span></span><br><span class="line">    <span class="string">while</span> <span class="string">(</span> <span class="literal">true</span> <span class="string">)&#123;</span></span><br><span class="line">        <span class="string">short</span> <span class="string">tmpst</span> <span class="string">=</span> <span class="string">(short)</span> <span class="string">(</span> <span class="string">b_name[</span> <span class="string">j</span> <span class="string">]</span> <span class="string">&amp;</span> <span class="number">0xF0</span> <span class="string">)</span> <span class="string">;</span></span><br><span class="line">        <span class="string">if</span> <span class="string">(</span> <span class="string">tmpst</span> <span class="string">&gt;=</span> <span class="number">0xB0</span> <span class="string">)&#123;</span></span><br><span class="line">            <span class="string">if</span> <span class="string">(</span> <span class="string">tmpst</span> <span class="string">&lt;</span> <span class="number">0xC0</span> <span class="string">)&#123;</span></span><br><span class="line">                <span class="string">j</span> <span class="string">+=</span> <span class="number">2</span> <span class="string">;</span></span><br><span class="line">                <span class="string">len</span> <span class="string">+=</span> <span class="number">2</span> <span class="string">;</span></span><br><span class="line">            <span class="string">&#125;</span></span><br><span class="line">            <span class="string">else</span> <span class="string">if</span> <span class="string">(</span> <span class="string">(</span> <span class="string">tmpst</span> <span class="string">==</span> <span class="number">0xC0</span> <span class="string">)</span> <span class="string">||</span> <span class="string">(</span> <span class="string">tmpst</span> <span class="string">==</span> <span class="number">0xD0</span> <span class="string">)</span> <span class="string">)&#123;</span></span><br><span class="line">                <span class="string">j</span> <span class="string">+=</span> <span class="number">2</span> <span class="string">;</span></span><br><span class="line">                <span class="string">len</span> <span class="string">+=</span> <span class="number">2</span> <span class="string">;</span></span><br><span class="line">            <span class="string">&#125;</span></span><br><span class="line">            <span class="string">else</span> <span class="string">if</span> <span class="string">(</span> <span class="string">tmpst</span> <span class="string">==</span> <span class="number">0xE0</span> <span class="string">)&#123;</span></span><br><span class="line">                <span class="string">j</span> <span class="string">+=</span> <span class="number">3</span> <span class="string">;</span></span><br><span class="line">                <span class="string">len</span> <span class="string">+=</span> <span class="number">2</span> <span class="string">;</span></span><br><span class="line">            <span class="string">&#125;</span></span><br><span class="line">            <span class="string">else</span> <span class="string">if</span> <span class="string">(</span> <span class="string">tmpst</span> <span class="string">==</span> <span class="number">0xF0</span> <span class="string">)&#123;</span></span><br><span class="line">                <span class="string">short</span> <span class="string">tmpst0</span> <span class="string">=</span> <span class="string">(short)</span> <span class="string">(</span> <span class="string">(</span> <span class="string">(short)</span> <span class="string">b_name[</span> <span class="string">j</span> <span class="string">]</span> <span class="string">)</span> <span class="string">&amp;</span> <span class="number">0x0F</span> <span class="string">)</span> <span class="string">;</span></span><br><span class="line">                <span class="string">if</span> <span class="string">(</span> <span class="string">tmpst0</span> <span class="string">==</span> <span class="number">0</span> <span class="string">)&#123;</span></span><br><span class="line">                    <span class="string">j</span> <span class="string">+=</span> <span class="number">4</span> <span class="string">;</span></span><br><span class="line">                    <span class="string">len</span> <span class="string">+=</span> <span class="number">2</span> <span class="string">;</span></span><br><span class="line">                <span class="string">&#125;</span></span><br><span class="line">                <span class="string">else</span> <span class="string">if</span> <span class="string">(</span> <span class="string">(</span> <span class="string">tmpst0</span> <span class="string">&gt;</span> <span class="number">0</span> <span class="string">)</span> <span class="string">&amp;&amp;</span> <span class="string">(</span> <span class="string">tmpst0</span> <span class="string">&lt;</span> <span class="number">12</span> <span class="string">)</span> <span class="string">)&#123;</span></span><br><span class="line">                    <span class="string">j</span> <span class="string">+=</span> <span class="number">5</span> <span class="string">;</span></span><br><span class="line">                    <span class="string">len</span> <span class="string">+=</span> <span class="number">2</span> <span class="string">;</span></span><br><span class="line">                <span class="string">&#125;</span></span><br><span class="line">                <span class="string">else</span> <span class="string">if</span> <span class="string">(</span> <span class="string">tmpst0</span> <span class="string">&gt;</span> <span class="number">11</span> <span class="string">)&#123;</span></span><br><span class="line">                    <span class="string">j</span> <span class="string">+=</span> <span class="number">6</span> <span class="string">;</span></span><br><span class="line">                    <span class="string">len</span> <span class="string">+=</span> <span class="number">2</span> <span class="string">;</span></span><br><span class="line">                <span class="string">&#125;</span></span><br><span class="line">            <span class="string">&#125;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        <span class="string">else&#123;</span></span><br><span class="line">            <span class="string">j</span> <span class="string">+=</span> <span class="number">1</span> <span class="string">;</span></span><br><span class="line">            <span class="string">len</span> <span class="string">+=</span> <span class="number">1</span> <span class="string">;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        <span class="string">if</span> <span class="string">(</span> <span class="string">j</span> <span class="string">&gt;</span> <span class="string">b_name.length</span> <span class="bullet">-</span> <span class="number">1</span> <span class="string">)&#123;</span></span><br><span class="line">            <span class="string">break</span> <span class="string">;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">return</span> <span class="string">len</span> <span class="string">;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-使用GBK编码解决"><a href="#5-2-使用GBK编码解决" class="headerlink" title="5.2 使用GBK编码解决"></a>5.2 使用GBK编码解决</h4><p>中文字符在Java中默认使用Unicode编码为一个字节，使用GBK编码则为两个字节，因此转出的Byte数组的长度和真是的中文格式的字符长度一致（包含中文特殊字符）</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">messageBody</span><span class="selector-class">.getBytes</span>(<span class="string">"GBK"</span>)<span class="selector-class">.length</span> <span class="comment">//中文字符长度都是两个字节</span></span><br></pre></td></tr></table></figure>
</div></article><div class="archive-pagination"><div class="paginator"><a class="extend prev" rel="prev" href="/archives/2017/">&laquo;</a><a class="page-number" href="/archives/2017/">1</a><span class="page-number current">2</span><a class="page-number" href="/archives/2017/page/3/">3</a><a class="page-number" href="/archives/2017/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/archives/2017/page/6/">6</a><a class="extend next" rel="next" href="/archives/2017/page/3/">&raquo;</a></div></div></div><div class="block-sidebar column one-fourth"><div class="widget text-content"><p>Agreek，河南人，技术宅，生于1993,12,23。</p>
<ul>
<li>毕业于<a href="http://www.zzuli.edu.cn/">郑州轻工业学院</a></li>
<li>一个努力前进的<a href="https://github.com/978420544/Demo">菜鸟</a></li>
<li>在 <a href="https://github.com/978420544">Github</a> 上积极参与开源社区</li>
</ul>
</div><div class="widget categories"><h3>分类</h3><hr><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bug/">Bug笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">MYSQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/quartz/">QUARTZ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sum/">Sum</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design/">设计模式</a></li></ul></div><div class="widget tags"><h3>标签</h3><hr><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/">Bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftp/">FTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proxy/">Proxy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quartz/">QUARTZ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/simpleblock/">Simpleblock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sum/">Sum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/">Xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transaction/">事物与锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/work/">职场</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/soul/">鸡汤</a></li></ul></div><div class="widget archives"><h3>归档</h3><hr><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li></ul></div><div class="widget text-content"><p>该博客使用基于 &nbsp;<a href="http://hexo.io">Hexo</a>&nbsp; 的 &nbsp;<a href="https://github.com/jysperm/hexo-theme-simpleblock">simpleblock</a>&nbsp; 主题。博客内容使用 &nbsp;<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn">CC BY-NC-SA 3.0</a>&nbsp; 授权发布。最后生成于 2022-05-12.</p></div></div></div></div><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><!--script.--><!--  const gitment = new Gitment({--><!--    id: document.location.href, // 可选。默认为 location.href--><!--    owner: '978420544',--><!--    repo: '978420544.github.io',--><!--    oauth: {--><!--      client_id: '446d9e1fab16c6a25a57',--><!--      client_secret: '9f0a1456f7c5cf1049b6bdce03a3b4ffd2c6ebfa',--><!--    },--><!--  })--><!--  gitment.render('container')--><!--script.--><!--  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {--><!--     window.Promise = null;--><!--  }--></body></html>