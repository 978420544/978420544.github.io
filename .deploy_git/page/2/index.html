<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="baidu-site-verification" content="nWXA5pz9OB&quot;"><meta name="google-site-verification" content="GV1JH1LWgxtYEzh1ZspR37dC-o6YZWuEfgCQLPnAAMM"><link rel="icon" href="/favicon.png"><link rel="alternate" type="application/rss+xml" title="Agreek的博客" href="https://978420544.github.io/atom.xml"><link rel="stylesheet" href="/styles.css"><link rel="stylesheet" href="/my.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><title>Agreek的博客</title></head><body><div class="container"><div class="columns page-header"><h1>Agreek的博客</h1></div><div class="columns"><div class="navigation"><nav class="menus-main"><a href="/" class="favicon"><img alt="Agreek的博客" src="/favicon.png"></a><a href="/">首页</a><a href="/archives">归档</a><a href="/resume">简历</a><a href="/about">关于</a></nav><nav class="right menus-right"><a href="/atom.xml">RSS</a><a target="_blank" href="https://github.com/978420544">fork on Github</a></nav></div></div><div class="columns"><div class="block-body column three-fourths"><div class="article-widget"><a href="https://github.com/978420544"></a></div><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-6：MySQL中的共享锁与排他锁/">转【数据库事务与锁】浅谈@6：MySQL中的共享锁与排他锁</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>在MySQL中的行级锁,表级锁,页级锁中介绍过，行级锁是Mysql中锁定粒度最细的一种锁，行级锁能大大减少数据库操作的冲突。行级锁分为共享锁和排他锁两种，本文将详细介绍共享锁及排他锁的概念、使用方式及注意事项等。</p>
<h3 id="共享锁-Share-Lock"><a href="#共享锁-Share-Lock" class="headerlink" title="共享锁(Share Lock)"></a>共享锁(Share Lock)</h3><p>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</p>
<p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><pre><code>SELECT ... LOCK IN SHARE MODE;
</code></pre><p>在查询语句后面增加LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p>
<h3 id="排他锁（eXclusive-Lock）"><a href="#排他锁（eXclusive-Lock）" class="headerlink" title="排他锁（eXclusive Lock）"></a>排他锁（eXclusive Lock）</h3><p>排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><pre><code>SELECT ... FOR UPDATE;
</code></pre><p>在查询语句后面增加FOR UPDATE，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB还有两个表锁：</p>
<pre><code>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁

意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。
</code></pre><p>意向锁是InnoDB自动加的，不需要用户干预。</p>
<p>对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。</p>
<pre><code>共享锁：SELECT ... LOCK IN SHARE MODE;

排他锁：SELECT ... FOR UPDATE;
</code></pre><p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506934.html" target="_blank" rel="noopener">《[数据库事务与锁]详解六: MySQL中的共享锁与排他锁》</a></p>
</div></article><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-5：MySQL中的行级锁-表级锁-页级锁/">转【数据库事务与锁】浅谈@5：MySQL中的行级锁,表级锁,页级锁'</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。<br>在数据库的锁机制中介绍过，在DBMS中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁.</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<h3 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h3><p>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁</p>
<h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><p>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h2 id="MySQL常用存储引擎的锁机制"><a href="#MySQL常用存储引擎的锁机制" class="headerlink" title="MySQL常用存储引擎的锁机制"></a>MySQL常用存储引擎的锁机制</h2><pre><code>MyISAM和MEMORY采用表级锁(table-level locking)
BDB采用页面锁(page-level locking)或表级锁，默认为页面锁
InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁
</code></pre><h3 id="Innodb中的行锁与表锁"><a href="#Innodb中的行锁与表锁" class="headerlink" title="Innodb中的行锁与表锁"></a>Innodb中的行锁与表锁</h3><p>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？</p>
<p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p>
<p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p>
<p>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</p>
<h3 id="行级锁与死锁"><a href="#行级锁与死锁" class="headerlink" title="行级锁与死锁"></a>行级锁与死锁</h3><p>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。</p>
<p>在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。</p>
<p>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。</p>
<p>发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p>
<hr>
<p>有多种方法可以避免死锁，这里只介绍常见的三种</p>
<pre><code>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；
</code></pre><p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506927.html" target="_blank" rel="noopener">《[数据库事务与锁]详解五: MySQL中的行级锁,表级锁,页级锁》</a></p>
</div></article><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-4：数据库的锁机制/">转【数据库事务与锁】浅谈@4：数据库的锁机制</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>数据库的读现象浅析中介绍过，在并发访问情况下，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。</p>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><pre><code>在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency control）是确保及时纠正由并发操作导致的错误的一种机制。
</code></pre><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。下面举例说明并发操作带来的数据不一致性问题：</p>
<p>现有两处火车票售票点，同时读取某一趟列车车票数据库中车票余额为 X。两处售票点同时卖出一张车票，同时修改余额为 X -1写回数据库，这样就造成了实际卖出两张火车票而数据库中的记录却只少了一张。 产生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。</p>
<p>封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。</p>
<p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。</p>
<h4 id="锁的分类-oracle"><a href="#锁的分类-oracle" class="headerlink" title="锁的分类(oracle)"></a>锁的分类(oracle)</h4><pre><code>一 按操作划分，可分为DML锁、DDL锁
二 按锁的粒度划分，可分为表级锁, 页级锁, 行级锁（mysql）
三 按锁级别划分，可分为共享锁、排它锁
四 按加锁方式划分，可分为自动锁、显示锁
五 按使用方式划分，可分为乐观锁, 悲观锁
</code></pre><p>DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))。 DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）</p>
<p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506823.html" target="_blank" rel="noopener">《[数据库事务与锁]详解四: 数据库的锁机制》</a></p>
</div></article><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-3：深入分析事务的隔离级别/">转【数据库事物与锁】浅谈@3：深入分析事务的隔离级别</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>在DBMS中，事务保证了一个操作序列可以全部都执行或者全部都不执行（原子性），从一个状态转变到另外一个状态（一致性）。由于事务满足久性。所以一旦事务被提交之后，数据就能够被持久化下来，又因为事务是满足隔离性的，所以，当多个事务同时处理同一个数据的时候，多个事务直接是互不影响的，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生脏读、不可重复读或者幻读等读现象。</p>
<p>在数据库事务的ACID四个属性中，隔离性是一个最常放松的一个。可以在数据操作过程中利用数据库的锁机制或者多版本并发控制机制获取更高的隔离等级。但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。</p>
<p>在软件开发中，几乎每类这样的问题都会有多种最佳实践来供我们参考，很多DBMS定义了多个不同的“事务隔离等级”来控制锁的程度和并发能力。</p>
<p>ANSI/ISO SQL定义的标准隔离级别有四种，从高到底依次为：可序列化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。</p>
<pre><code>本文详细介绍四种事务隔离级别，并通过举例的方式说明不同的级别能解决什么样的读现象。
并且介绍了在关系型数据库中不同的隔离级别的实现原理。

下面将依次介绍这四种事务隔离级别的概念、用法以及解决了哪些问题（读现象）
</code></pre><h3 id="未提交读-Read-uncommitted"><a href="#未提交读-Read-uncommitted" class="headerlink" title="未提交读(Read uncommitted)"></a>未提交读(Read uncommitted)</h3><p>未提交读(READ UNCOMMITTED)是最低的隔离级别。通过名字我们就可以知道，在这种事务隔离级别下，一个事务可以读到另外一个事务未提交的数据。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>事务在读数据的时候并未对数据加锁。
事务在修改数据的时候只对数据增加行级共享锁。
</code></pre><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><pre><code>事务1读取某行记录时，事务2也能对这行记录进行读取、更新（因为事务一并未对数据增加任何锁）

当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本（因为事务二只增加了共享读锁，事务一可以再增加共享读锁读取数据），即使该修改尚未被提交。

事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（因为事务一对数据增加了共享读锁，事务二不能增加排他写锁进行数据的修改）
</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>事务一共查询了两次，在两次查询的过程中，事务二对数据进行了修改，并未提交（commit）。
但是事务一的第二次查询查到了事务二的修改结果。在数据库的读现象浅析中我们介绍过，这种现象我们称之为脏读。

所以，未提交读会导致脏读
</code></pre><h3 id="提交读-Read-committed"><a href="#提交读-Read-committed" class="headerlink" title="提交读(Read committed)"></a>提交读(Read committed)</h3><p>提交读(READ COMMITTED)也可以翻译成读已提交，通过名字也可以分析出，在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。</p>
<h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><pre><code>事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
</code></pre><h4 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h4><pre><code>事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据。）。

事务1读取某行的一瞬间，事务2不能修改该行数据，但是，只要事务1读取完改行数据，事务2就可以对该行数据进行修改。（事务一在读取的一瞬间会对数据增加共享锁，任何其他事务都不能对该行数据增加排他锁。但是事务一只要读完该行数据，就会释放行级共享锁，一旦锁释放，事务二就可以对数据增加排他锁并修改数据）

事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（事务一在更新数据的时候，会对该行数据增加排他锁，知道事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）
</code></pre><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>提交读这种隔离级别保证了读到的任何数据都是提交的数据，避免了脏读(dirty reads)。但是不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据。</p>
<h3 id="可重复读-Repeatable-reads"><a href="#可重复读-Repeatable-reads" class="headerlink" title="可重复读(Repeatable reads)"></a>可重复读(Repeatable reads)</h3><p>可重复读(REPEATABLE READS),由于提交读隔离级别会产生不可重复读的读现象。所以，比提交读更高一个级别的隔离级别就可以解决不可重复读的问题。这种隔离级别就叫可重复读（这名字起的是不是很任性！！）</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><pre><code>事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
</code></pre><h4 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h4><pre><code>事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据。）。

事务1在读取某行记录的整个过程中，事务2都不能修改该行数据（事务一在读取的整个过程会对数据增加共享锁，直到事务提交才会释放锁，所以整个过程中，任何其他事务都不能对该行数据增加排他锁。所以，可重复读能够解决不可重复读的读现象）

事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（事务一在更新数据的时候，会对该行数据增加排他锁，知道事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）
</code></pre><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>1.事务一的第一次查询条件是age BETWEEN 10 AND 30;如果这是有十条记录符合条件。这时，他会给符合条件的这十条记录增加行级共享锁。任何其他事务无法更改这十条记录。</p>
<p>2.事务二执行一条sql语句，语句的内容是向表中插入一条数据。因为此时没有任何事务对表增加表级锁，所以，该操作可以顺利执行。</p>
<p>3.事务一再次执行SELECT * FROM users WHERE age BETWEEN 10 AND 30;时，结果返回的记录变成了十一条，比刚刚增加了一条，增加的这条正是事务二刚刚插入的那条。</p>
<p>所以，事务一的两次范围查询结果并不相同。这也就是幻读。</p>
<h3 id="可序列化-Serializable"><a href="#可序列化-Serializable" class="headerlink" title="可序列化(Serializable)"></a>可序列化(Serializable)</h3><p>可序列化(Serializable)是最高的隔离级别，前面提到的所有的隔离级别都无法解决的幻读，在可序列化的隔离级别中可以解决。</p>
<p>我们说过，产生幻读的原因是事务一在进行范围查询的时候没有增加范围锁(range-locks：给SELECT 的查询中使用一个“WHERE”子句描述范围加锁），所以导致幻读。</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><pre><code>事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；

事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。
</code></pre><h4 id="现象-4"><a href="#现象-4" class="headerlink" title="现象"></a>现象</h4><pre><code>事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。(因为事务一对表增加了表级共享锁，其他事务只能增加共享锁读取数据，不能进行其他任何操作）

事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。（事务一对表增加了表级排他锁，其他事务不能对表增加共享锁或排他锁，也就无法进行任何操作）
</code></pre><p>虽然可序列化解决了脏读、不可重复读、幻读等读现象。但是序列化事务会产生以下效果：</p>
<p>1.无法读取其它事务已修改但未提交的记录。</p>
<p>2.在当前事务完成之前，其它事务不能修改目前事务已读取的记录。</p>
<p>3.在当前事务完成之前，其它事务所插入的新记录，其索引键值不能在当前事务的任何语句所读取的索引键范围中。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>四种事务隔离级别从隔离程度上越来越高，但同时在并发性上也就越来越低。之所以有这么几种隔离级别，就是为了方便开发人员在开发过程中根据业务需要选择最合适的隔离级别。</p>
<p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506755.html" target="_blank" rel="noopener">《[数据库事务与锁]详解三: 深入分析事务的隔离级别》</a></p>
</div></article><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-2：数据库的读现象/">转【数据库事务与锁】浅谈@2：数据库的读现象</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。其中包括脏读、不可重复读和幻读。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</p>
<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</p>
<p>一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><pre><code>幻读(phantom read)”是不可重复读(Non-repeatable reads)的一种特殊场景：当事务没有获取范围锁的情况下执行SELECT … WHERE操作可能会发生“幻影读(phantom read)”。
</code></pre><p>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检锁范围为只读，这样就避免了幻读。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>要想解决脏读、不可重复读、幻读等读现象，那么就需要提高事务的隔离级别。但与此同时，事务的隔离级别越高，并发能力也就越低。所以，还需要读者根据业务需要进行权衡。</p>
<p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506755.html" target="_blank" rel="noopener">《[数据库事务与锁]详解二: 数据库的读现象浅析》</a></p>
</div></article><article><header><h2><a href="/2017/10/10/转【数据库事务与锁】浅谈-1：彻底理解数据库事务/">转【数据库事务与锁】浅谈@1：彻底理解数据库事务</a></h2></header><div class="article-meta clearfix"><time class="left">2017-10-10</time><ul class="tags left"><li><a href="/categories/mysql/">MYSQL</a></li></ul><ul class="tags right"><li><a href="/tags/transaction/">事物与锁</a></li></ul></div><div class="markdown-body"><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p>
<pre><code>1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。
</code></pre><p>当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</p>
<p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>
<pre><code>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。
</code></pre><h4 id="原子性与隔离行"><a href="#原子性与隔离行" class="headerlink" title="原子性与隔离行"></a>原子性与隔离行</h4><p>一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关。<br>比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。</p>
<p>因此，事务的原子性与一致性缺一不可。</p>
<p>–转自 <a href="http://www.cnblogs.com/wang-meng/p/5506745.html" target="_blank" rel="noopener">《[数据库事务与锁]详解一: 彻底理解数据库事务》</a></p>
<h3 id="特性浅析"><a href="#特性浅析" class="headerlink" title="特性浅析"></a>特性浅析</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><pre><code>无论一个事务里有多少执行步骤，这所有的步骤合起来是一个最小的执行单元，要么不做，要么全做，不存在只做到一半情况。比如银行转账，转出跟转入这两个包含在一个事务里的动作就是原子的。要么不转出也不转入，转出了就要转入。
</code></pre><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><pre><code>事务执行前与执行后数据内在的逻辑始终是成立的。比如转账前与转账后两人存款的总和始终不变。
</code></pre><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><pre><code>虽说事务是原子的，要么不做，要么全做，不存在做一半的情况。但是从代码实现上来说，事务里的步骤还是一步一步执行的，还是存在事务做到一半的情况。比如转账，代码怎么写？就两行代码，是先转出扣钱，再转入加钱。两行代码中间，也就是转出之后，转入之前，此时数据是不一致的。那怎样始终保证数据一致？那就用一个类似自欺欺人的办法，让转账这个事务在完成之前对别人都不可见，事务完成之前别人看到的都是转账前的状态，看不到转账步骤中间不一致的状态，所谓”隔离”。
</code></pre><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><pre><code>事务做完了就是做完了，就生效了。就像钱转给别人后当前这比转账交易就结束了，不可能再倒回来。
</code></pre></div></article><div class="archive-pagination"><div class="paginator"><a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a></div></div></div><div class="block-sidebar column one-fourth"><div class="widget text-content"><p>Agreek，河南人，技术宅，生于1993,12,23。</p>
<ul>
<li>毕业于<a href="http://www.zzuli.edu.cn/">郑州轻工业学院</a></li>
<li>一个努力前进的<a href="https://github.com/978420544/Demo">菜鸟</a></li>
<li>在 <a href="https://github.com/978420544">Github</a> 上积极参与开源社区</li>
</ul>
</div><div class="widget categories"><h3>分类</h3><hr><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bug/">Bug笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">MYSQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/quartz/">QUARTZ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sum/">Sum</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design/">设计模式</a></li></ul></div><div class="widget tags"><h3>标签</h3><hr><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/">Bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftp/">FTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proxy/">Proxy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quartz/">QUARTZ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/simpleblock/">Simpleblock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sum/">Sum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/">Xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transaction/">事物与锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/work/">职场</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/soul/">鸡汤</a></li></ul></div><div class="widget archives"><h3>归档</h3><hr><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li></ul></div><div class="widget text-content"><p>该博客使用基于 &nbsp;<a href="http://hexo.io">Hexo</a>&nbsp; 的 &nbsp;<a href="https://github.com/jysperm/hexo-theme-simpleblock">simpleblock</a>&nbsp; 主题。博客内容使用 &nbsp;<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn">CC BY-NC-SA 3.0</a>&nbsp; 授权发布。最后生成于 2022-05-12.</p></div></div></div></div><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><!--script.--><!--  const gitment = new Gitment({--><!--    id: document.location.href, // 可选。默认为 location.href--><!--    owner: '978420544',--><!--    repo: '978420544.github.io',--><!--    oauth: {--><!--      client_id: '446d9e1fab16c6a25a57',--><!--      client_secret: '9f0a1456f7c5cf1049b6bdce03a3b4ffd2c6ebfa',--><!--    },--><!--  })--><!--  gitment.render('container')--><!--script.--><!--  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {--><!--     window.Promise = null;--><!--  }--></body></html>